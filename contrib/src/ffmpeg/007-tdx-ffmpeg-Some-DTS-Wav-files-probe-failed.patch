From 2d6287dc65bad11adc4fc61ff0816bad821be28d Mon Sep 17 00:00:00 2001
From: shixuehui <shixuehui@zspace.cn>
Date: Wed, 24 Jul 2024 19:42:39 +0800
Subject: [PATCH] Some DTS/Wav files probe failed.

---
 libavformat/wavdec.c | 43 +++++++++++++++++++++++++++++++------------
 1 file changed, 31 insertions(+), 12 deletions(-)

diff --git a/libavformat/wavdec.c b/libavformat/wavdec.c
index 4924d8f0fb..6588ca2973 100644
--- a/libavformat/wavdec.c
+++ b/libavformat/wavdec.c
@@ -145,22 +145,36 @@ static int64_t find_tag(WAVDemuxContext * wav, AVIOContext *pb, uint32_t tag1)
     return size;
 }
 
+static int offset_h = 0;
 static int wav_probe(const AVProbeData *p)
 {
     /* check file header */
-    if (p->buf_size <= 32)
+    if (p->buf_size <= 1024)
         return 0;
-    if (!memcmp(p->buf + 8, "WAVE", 4)) {
-        if (!memcmp(p->buf, "RIFF", 4) || !memcmp(p->buf, "RIFX", 4))
-            /* Since the ACT demuxer has a standard WAV header at the top of
-             * its own, the returned score is decreased to avoid a probe
-             * conflict between ACT and WAV. */
-            return AVPROBE_SCORE_MAX - 1;
-        else if ((!memcmp(p->buf,      "RF64", 4) ||
-                  !memcmp(p->buf,      "BW64", 4)) &&
-                 !memcmp(p->buf + 12, "ds64", 4))
-            return AVPROBE_SCORE_MAX;
-    }
+    int i = 0, meet_wave = 0;
+    do {
+        if (!memcmp(p->buf + 8 + i, "WAVE", 4)) {
+            meet_wave++;
+        }
+        i++;
+        if (meet_wave >= 2)
+            return AVPROBE_SCORE_RETRY;
+    }while(i < 256);
+    offset_h = 0;
+    do {
+        if (!memcmp(p->buf + 8 + offset_h, "WAVE", 4)) {
+            if (!memcmp(p->buf + offset_h, "RIFF", 4) || !memcmp(p->buf + offset_h, "RIFX", 4))
+                /* Since the ACT demuxer has a standard WAV header at the top of
+                 * its own, the returned score is decreased to avoid a probe
+                 * conflict between ACT and WAV. */
+                return AVPROBE_SCORE_MAX - 1;
+            else if ((!memcmp(p->buf + offset_h,      "RF64", 4) ||
+                      !memcmp(p->buf + offset_h,      "BW64", 4)) &&
+                     !memcmp(p->buf + 12 + offset_h, "ds64", 4))
+                return AVPROBE_SCORE_MAX;
+        }
+        offset_h++;
+    }while(offset_h < 16);
     return 0;
 }
 
@@ -350,12 +364,16 @@ static int wav_read_header(AVFormatContext *s)
     int ret, got_fmt = 0, got_xma2 = 0;
     int64_t next_tag_ofs, data_ofs = -1;
 
+    //av_log(s, AV_LOG_WARNING, "offset_h=%d\n", offset_h);
+    avio_skip(pb, offset_h);
     wav->unaligned = avio_tell(s->pb) & 1;
 
     wav->smv_data_ofs = -1;
 
+
     /* read chunk ID */
     tag = avio_rl32(pb);
+    //av_log(s, AV_LOG_WARNING, "start code %s in RIFF header\n", av_fourcc2str(tag));
     switch (tag) {
     case MKTAG('R', 'I', 'F', 'F'):
         break;
@@ -413,6 +431,7 @@ static int wav_read_header(AVFormatContext *s)
         AVStream *vst;
         size         = next_tag(pb, &tag, wav->rifx);
         next_tag_ofs = avio_tell(pb) + size;
+        //av_log(s, AV_LOG_WARNING, "tag[%s] size=%lld, offset=%lld.\n", av_fourcc2str(tag), size, next_tag_ofs-size);
 
         if (avio_feof(pb))
             break;
-- 
2.39.1

